/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mf.customization.spring;

import java.util.ArrayList;
import mf.classmetadata.Annotation;
import mf.classmetadata.ClassField;
import mf.classmetadata.ClassImport;
import mf.classmetadata.ClassMetadata;
import mf.classmetadata.ClassRelationshipFieldType;
import mf.customization.MfClassCustomization;
import mf.schema.model.MfEntity;
import mf.schema.model.MfRelationship;
import mf.schema.model.MfSchema;

/**
 *
 * @author evand
 */
public class MfSpringMongoCustomization extends MfClassCustomization {
    
    public MfEntity applyCustomizationsTo(MfEntity entityClassMetadata) {
       
        forRootClass(entityClassMetadata);
        
        forNestedClasses(entityClassMetadata);
        
        return entityClassMetadata;
        
    }
    
    // 1 - Applying customization for the rootClass
    private void forRootClass(MfEntity entityClassMetadata){
        // The entity was generated by DAG structure and it can has a plan or a hierarchy structure.
        // If the entity has an hierachy structure, then we need to get the Root Entity and customize with some annotations, as @Document.
        
        // According the structure of the DAG, the last added class in classMetadataList is the Root Entity.
        ClassMetadata rootClassMetadata = entityClassMetadata.getClassMetadataList().get(entityClassMetadata.getClassMetadataList().size() - 1);
        
        rootClassMetadata.getImports().add(new ClassImport("org.springframework.data.annotation.Id"));
        rootClassMetadata.getImports().add(new ClassImport("org.springframework.data.mongodb.core.mapping.Document"));

        rootClassMetadata.getAnnotations().add(new Annotation("@Document(collection = \"" + rootClassMetadata.getName() + "\")"));
        
        ClassField id = new ClassField("private", "String", "_id", ClassRelationshipFieldType.NONE, true, false);
        id.getAnnotations().add(new Annotation("@Id"));
        id.setPk(true);

        rootClassMetadata.updateOrAddClassField(id);
    }
    
    
    // 2 - Applying customization for the other classes (no root classes).
    private void forNestedClasses(MfEntity entityClassMetadata){
        // According the structure of the DAG, the last added class in classMetadataList is the Root Entity.
        ClassMetadata rootClassMetadata = entityClassMetadata.getClassMetadataList().get(entityClassMetadata.getClassMetadataList().size() - 1);
        
        for (ClassMetadata clazz : entityClassMetadata.getClassMetadataList()) {
            
            if (rootClassMetadata == clazz) {
                break;
            }
            
            // if you need imports, annotations or new class fields for the nested entities, then discomment the code and add it below.
            //clazz.getImports().add( ? );
            //clazz.getAnnotations().add( ? );
            //clazz.updateOrAddClassField( ? );
        }
    }

    @Override
    public MfSchema applyCustomizationsTo(MfSchema schema) {
        
        ArrayList<ClassField> listOfFieldsAlreadyProcessed = new ArrayList<>();
        
        for (MfRelationship rel : schema.getRelationships()){
            // Retrieving the ClassMetadata of the relationship (type reference)
            ClassMetadata onesideClazz = rel.getOneSideClassMetadata();
            ClassMetadata manysideClazz = rel.getManySideClassMetadata();
            
            // Adding Spring Data imports
            onesideClazz.getImports().add(new ClassImport("org.springframework.data.annotation.ReadOnlyProperty"));
            onesideClazz.getImports().add(new ClassImport("org.springframework.data.mongodb.core.mapping.DocumentReference"));
            manysideClazz.getImports().add(new ClassImport("org.springframework.data.mongodb.core.mapping.DocumentReference"));
            
            // If the relationship between classes is of type ARRAY_OF_OBJECTS, then add "DocumentReference" annotation of type ReadOnlyProperty
            for (ClassField clazzField : onesideClazz.getFields()) {
                if (clazzField.getRelationshipType() == ClassRelationshipFieldType.ARRAY_OF_OBJECTS && !listOfFieldsAlreadyProcessed.contains(clazzField)){
                    clazzField.getAnnotations().add(new Annotation("@ReadOnlyProperty"));
                    clazzField.getAnnotations().add(
                            new Annotation(
                                    String.format("@DocumentReference(lookup = \"{ '%s' : ?#{#self.%s} }\")", 
                                            clazzField.getRefForeignFieldName(), 
                                            clazzField.getRefLocalFieldName()
                                    )
                            )
                    );
                    
                    listOfFieldsAlreadyProcessed.add(clazzField);
                }
            }
            
            // If the relationship between classes is of type OBJECT, then add "DocumentReference" annotation
            for (ClassField clazzField : manysideClazz.getFields()) {
                if (clazzField.getRelationshipType() == ClassRelationshipFieldType.OBJECT && !listOfFieldsAlreadyProcessed.contains(clazzField)){
                    clazzField.getAnnotations().add(
                            new Annotation(
//                                    String.format("@DocumentReference(lookup = \"{ '%s' : ?#{%s} }\")",
                                      String.format("@DocumentReference(lookup = \"{ '%s' : ?#{#self.%s} }\")",
                                            clazzField.getRefForeignFieldName(), 
                                            clazzField.getRefLocalFieldName()
                                    )
                            )
                    );
                    
                    listOfFieldsAlreadyProcessed.add(clazzField);
                }
            }
        }
        
        return schema;
    }
}